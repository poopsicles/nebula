<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Ball Class - Nebula: The Definitive Pygame Course</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "coal" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../Introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Getting Started with Python</li><li class="chapter-item expanded "><a href="../Python/Variables.html"><strong aria-hidden="true">2.</strong> Variables</a></li><li class="chapter-item expanded "><a href="../Python/Strings.html"><strong aria-hidden="true">3.</strong> Strings</a></li><li class="chapter-item expanded "><a href="../Python/Functions.html"><strong aria-hidden="true">4.</strong> Functions</a></li><li class="chapter-item expanded "><a href="../Python/Logic.html"><strong aria-hidden="true">5.</strong> Logic</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Python/Conditionals.html"><strong aria-hidden="true">5.1.</strong> Conditionals</a></li><li class="chapter-item expanded "><a href="../Python/Loops.html"><strong aria-hidden="true">5.2.</strong> Loops</a></li><li class="chapter-item expanded "><a href="../Python/Lists-I.html"><strong aria-hidden="true">5.3.</strong> Accessing Lists</a></li><li class="chapter-item expanded "><a href="../Python/Lists-II.html"><strong aria-hidden="true">5.4.</strong> List Operations</a></li></ol></li><li class="chapter-item expanded "><a href="../Python/Dictionaries.html"><strong aria-hidden="true">6.</strong> Dictionaries</a></li><li class="chapter-item expanded "><a href="../Python/OOP.html"><strong aria-hidden="true">7.</strong> Object-Oriented Programming</a></li><li class="chapter-item expanded affix "><li class="part-title">Working with Pygame</li><li class="chapter-item expanded "><a href="../Pygame/Pygame-I.html"><strong aria-hidden="true">8.</strong> Introduction to Pygame</a></li><li class="chapter-item expanded "><a href="../Pygame/Pygame-II.html"><strong aria-hidden="true">9.</strong> Doing more with Pygame</a></li><li class="chapter-item expanded affix "><li class="part-title">Real-World Examples</li><li class="chapter-item expanded "><a href="../Pong/Intro.html"><strong aria-hidden="true">10.</strong> Pong</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Pong/Player.html"><strong aria-hidden="true">10.1.</strong> The Player Class</a></li><li class="chapter-item expanded "><a href="../Pong/Ball.html" class="active"><strong aria-hidden="true">10.2.</strong> The Ball Class</a></li><li class="chapter-item expanded "><a href="../Pong/Score.html"><strong aria-hidden="true">10.3.</strong> Showing Information</a></li><li class="chapter-item expanded "><a href="../Pong/Loop.html"><strong aria-hidden="true">10.4.</strong> Putting it all together</a></li><li class="chapter-item expanded "><a href="../Pong/Final.html"><strong aria-hidden="true">10.5.</strong> Final Code</a></li></ol></li><li class="chapter-item expanded "><a href="../Space/Intro.html"><strong aria-hidden="true">11.</strong> Space Invaders</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Space/Player.html"><strong aria-hidden="true">11.1.</strong> Implementing the Player</a></li><li class="chapter-item expanded "><a href="../Space/Enemies.html"><strong aria-hidden="true">11.2.</strong> Adding Enemies</a></li><li class="chapter-item expanded "><a href="../Space/Bullets.html"><strong aria-hidden="true">11.3.</strong> Bullets and Shooting</a></li><li class="chapter-item expanded "><a href="../Space/Scoring.html"><strong aria-hidden="true">11.4.</strong> Adding Scoring</a></li><li class="chapter-item expanded "><a href="../Space/More.html"><strong aria-hidden="true">11.5.</strong> Adding More Enemies</a></li><li class="chapter-item expanded "><a href="../Space/Finish.html"><strong aria-hidden="true">11.6.</strong> Finishing Touches</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Nebula: The Definitive Pygame Course</h1>

                    <div class="right-buttons">

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="implementation-of-the-ball"><a class="header" href="#implementation-of-the-ball">Implementation of the ball</a></h1>
<p>In this section, we are going to implement the ball class. This is the entire crux of our game. This class is the bulkiest and the most tricky because it defines basically all of our game. Enough talking let’s just get started with it </p>
<h2 id="logic-of-the-ball"><a class="header" href="#logic-of-the-ball">Logic of the ball</a></h2>
<p>Before we dive into the code we need to know what we are going to implement. We need to talk about <em>logic</em>.
The first thing that we need to talk about is how the ball will move around.
The ball is meant to move in an angle that will be gotten from a list of all possible angles</p>
<p>The angles that the game should support should be</p>
<pre><code class="language-python">possible_angles = [15, 45, 60, 120, 150, 135]
</code></pre>
<p>To make the ball move in a direction we use a <strong>Vector</strong>.</p>
<p>A <strong>Vector</strong> can be thought of as an arrow that just points in a direction(In our case it points at an angle). 
The vector has an <strong>angle</strong> that is going to be pointing at and a <strong>magnitude</strong> that represents how long it is(The <strong>magnitude</strong> for us will just the speed of the ball). 
We can use multiple vectors to move an object in a specified direction.</p>
<p>A vector has two components, the <strong>x component</strong> and the <strong>y component</strong>. 
The <strong>x component</strong> just specifies which the speed which the vector is moving in the x direction and the <strong>y component</strong> specifies the speed at which it moves in the y direction.</p>
<p>We can calculate the x and y component of a vector using the following formula</p>
<pre><code>x_component = (magnitude * cos(angle))
y_component = (magnitude * sin(angle))
</code></pre>
<p>For our game we will just need one vector to specify which angle the ball is going to be moving in.</p>
<p>So to get the ball moving in the direction of the vector we just calculate the x and y component of the vector and then add it to the ball’s x and y location.</p>
<p>And that should be all for moving the ball.</p>
<p>But wait we are not yet done with the <em>logic</em> of the ball.</p>
<p>We still have one major hurdle to overcome which is…<strong>Collisions</strong>.</p>
<p>So we are going to talk about collisions right now.</p>
<p>The requirements that we would need for our game’s collision is as follows</p>
<ol>
<li>We need to know when we collide with any side of the screen and we also need to check if we collide with the paddles.</li>
<li>If we collide, we then need to reverse the direction of the vector and also check if we scored so that we increment the score counter for the other player and reset the game state.</li>
<li>And I think that’s all??</li>
</ol>
<p>So let’s get right into it.</p>
<p>First we can easily check if two rectangle in pygame by using a method in the <code>pygame.rect.Rect</code> class called <code>colliderect</code>.
The <code>colliderect</code> function returns <code>True</code> or <code>False</code> depending on if two rectangles collide.
We will use that to check if we collide with a paddle.</p>
<p>So now checking collisions with the screen, this was discussed in one of your previous chapters but for sake of emphasis, let’s just talk about them again.</p>
<p>All we just need to check if we,</p>
<ol>
<li>Collide with the top or the bottom of the screen, so that we can reverse the direction of the ball so that it can bounce</li>
<li>Collide with the left or the right of the screen, so that we can then increase the score of the player that scored.</li>
</ol>
<p>First, let’s do collisions with the top and the bottom of the screen.</p>
<p>In order to check if the ball collides with the top of the screen, we just need to check the if the ball’s y location is less than zero, we flip the y component of the ball so that the ball then start’s pointing down but keeps moving in the original x direction.</p>
<p>We can reverse the <strong>y component</strong> by multiplying it by -1</p>
<pre><code class="language-python">if(self.rect.y &lt; 0):
	self.y_component *= -1
</code></pre>
<p>Since that’s done, we then need to check if the ball collides with the bottom of the screen.</p>
<p>To check if the ball has collided with the bottom of the screen, we just check if the ball’s y location + the ball’s height is greater than the height of the screen. If it collides, we also flip the <strong>y component</strong> of the vector</p>
<pre><code class="language-python">if (self.rect.y + self.rect.h &gt; screen_height):
	self.y_component *= -1
</code></pre>
<p>So the final snippet for checking if the ball collides with either the top or the bottom of the screen would be</p>
<pre><code class="language-python">if self.body.y &lt;= 0 or self.body.y + self.body.h &gt;= screen_height:
	self.y_component *= -1
</code></pre>
<p>Now on to the next step, we need to then check if we collide with either of the paddles.</p>
<p>The logic for this is quite similar to the logic for checking if the ball collides with the top or bottom part of the screen. 
It’s just that all we have to do when we collide with a paddle is instead of flipping the <strong>y component</strong> we flip the <strong>x component</strong> of the vector.</p>
<p>We can check if the ball is colliding with a paddle by just calling the function <code>colliderect</code> on the ball’s rectangle object and the paddle’s rectangle object.</p>
<p>So the code for that would look like</p>
<pre><code class="language-python">if self.rect.colliderect(left_paddle.rect) or self.rect.colliderect(right_paddle.rect):
	self.x_component *= -1
</code></pre>
<p>So we successfully have a ball that can bounce around.</p>
<p>All that remains is just one final step, which is to just to check if the ball collides with either the left side of the screen.</p>
<p>So all we need to do is just check if we collide with either the left side or the right side of the screen.</p>
<p>We can easily do this by just checking if the ball’s x location is less than zero or if the ball’s location + the ball’s width is greater than the screen width. And if we collide with the sides, we increment the score for the player at the other side and call the reset function of the ball.</p>
<p>So for the left side it would be</p>
<pre><code class="language-python">if self.x &lt; 0:
	right_score += 1
	self.reset()
</code></pre>
<p>So for the right side, it would be</p>
<pre><code class="language-python">if self.rect.x + self.rect.w &gt; screen_width:
	left_score += 1
	self.reset()
</code></pre>
<p>And now we should be done with collisions right? Right?</p>
<p>Nah</p>
<p>With our current implementation of the collisions we would have errors, lemme explain</p>
<p>Let’s take a look at where we are checking collision between two paddles and where we are checking if we collide with the left or right edge of the screen.</p>
<pre><code class="language-python">if self.rect.colliderect(left_paddle.rect) or self.rect.colliderect(right_paddle.rect):
	self.x_component *= -1

if self.rect.x &lt; 0:
	right_score += 1
	self.reset()

if self.rect.x + self.rect.w &gt; screen_width:
	left_score += 1
	self.reset()
</code></pre>
<p>The major problem with this implementation is that the ball which collides with a paddle could collide with the paddle and also touch the edge of the screen which would then cause the following events to occur.</p>
<ul>
<li>The ball’s x component is reversed</li>
<li>The check for the score occurs which will return true and treat the collision as a goal scored which will then reset the game.</li>
</ul>
<p>This is a problem because the second event is not meant to occur at all.</p>
<p>We can fix this by checking if the ball is colliding with a paddle and if so it shouldn’t increment the score or reset the game.</p>
<p>The code for the changing the score will then look like this.</p>
<pre><code class="language-python">if self.rect.x &lt;= 0 and not self.rect.colliderect(left_paddle.rect):
	right_score += 1
	self.reset(left_paddle, right_paddle)


if self.rect.x + self.rect.w &gt;= screen_width and not self.rect.colliderect(right_paddle.rect):
	left_score += 1
	self.reset(left_paddle, right_paddle)
</code></pre>
<p>That should fix the problem.</p>
<p>So we are done again right? Right?</p>
<p>I think you know the answer to this question</p>
<p>So the other major problem that we could have is kinda like a snake in the grass of errors. 
It something that has to do with the with flipping the ball’s x component when we collide with a paddle.</p>
<p>Why don’t you try to figure out the problem by looking at the code?</p>
<p>You done?</p>
<p>So after you skipped over the last two lines, lemme explain this other problem.</p>
<p>Let’s look at the snippet in question</p>
<pre><code class="language-python">if self.rect.colliderect(left_paddle.rect) or self.rect.colliderect(right_paddle.rect):
	self.x_component *= -1
</code></pre>
<p>We reverse the x component when we collide with a paddle.
The ball is inside the paddle and then when the x direction is reversed the ball could still be inside the paddle causing the ball x direction to then reverse again and again till it get’s out of the paddle.</p>
<p>We can fix this by checking if the ball is inside the rectangle and then if that is true we shouldn’t be able to reverse the x component until it we stop colliding with a paddle.</p>
<pre><code class="language-python">if self.rect.colliderect(left_paddle.rect) or self.rect.colliderect(right_paddle.rect):
	if self.should_check:
		self.x_component *= -1
		self.should_check = False
else:
	self.should_check = True
</code></pre>
<p>And with this should fix the problem that we were having.</p>
<p>So are we done now? Please tell me that we are done?</p>
<p>Yeah we finally done with all the stuff</p>
<p>We can now go the definition of the methods of the class</p>
<h2 id="the-init-method"><a class="header" href="#the-init-method">The Init method</a></h2>
<p>In this method, we need to define stuff that the ball class is going to use</p>
<pre><code class="language-python">class Ball:
    def __init__(self):
        # ? This is the size of the ball
        self.size = 20

        # ? This calculates the center position of the screen
        center_horizontal = (screen_width - self.size) / 2
        center_vertical = (screen_height - self.size) / 2

        # ? This is pygame rectangle object that gets drawn onto the screen
        self.rect = pygame.Rect(
            center_horizontal, center_vertical, self.size, self.size)

        # ? This chooses a random angle for velocity vector
        self.angle = random.choice(possible_angles)

        # ? This is the x component of the velocity vector
        self.x_component = cos(radians(self.angle))

        # ? This is the y component of the velocity vector
        self.y_component = sin(radians(self.angle))

        # ? This is the speed of the ball
        self.speed = 15

        self.should_check = True

</code></pre>
<p>We calculate the <code>self.x_component</code> and <code>self.y_component</code> after we choose a random angle from the list of possible angles we calculate the components</p>
<h2 id="the-reset-method"><a class="header" href="#the-reset-method">The Reset Method</a></h2>
<p>This method just sets the ball back to the middle of the screen and calls the reset method on both paddles. 
The new angle at which the ball shoots is rechosen
We also recalculate the x and y component of the vector that is being added to the ball.</p>
<p>The code for the method will look like:</p>
<pre><code class="language-python">    def reset(self, left_paddle: Player, right_paddle: Player):

		self.angle = random.choice(possible_angles)
        self.rect.x = (screen_width - self.size) / 2
        self.rect.y = (screen_height - self.size) / 2
        self.x_component = cos(radians(self.angle))
        self.y_component = sin(radians(self.angle))
        left_paddle.reset()
        right_paddle.reset()
</code></pre>
<p>And that concludes the reset method for the ball.</p>
<h2 id="the-check-collision-method"><a class="header" href="#the-check-collision-method">The check collision method</a></h2>
<p>This is the method that majority of this method was already implemented in the “<em>logic</em>” section of the ball class.</p>
<p>Let’s just dive right in.</p>
<p>The first thing that we do is just declare some global variable that we are going to change</p>
<pre><code class="language-python">        # ? We tell the interpreter that we are about to modify some global variables
        global left_score, right_score, wait_timer
</code></pre>
<p>We have the two variables that hold the score of each player and the <code>wait_timer</code> that would be explained in a bit.</p>
<p>After we declare our global variables, we check if the ball has collided with the top or bottom side of the screen</p>
<pre><code class="language-python">        if self.rect.y &lt;= 0 or self.rect.y + self.rect.h &gt;= screen_height:
            self.y_component *= -1
</code></pre>
<p>Then we check if the ball has collided with any of the paddles so that we can then reverse the <code>x_component</code> of the ball.</p>
<pre><code class="language-python">        # ? Checking if the ball collides with the left paddle
        if self.rect.colliderect(left_paddle.rect) or self.rect.colliderect(right_paddle.rect):
            if self.should_check:
                self.x_component *= -1
                self.should_check = False
        else:
            self.should_check = True
</code></pre>
<p>The code above has already been explained.</p>
<p>The final thing that we do in this method is to then check if we collide the left or right edge of the screen.</p>
<pre><code class="language-python">        # ? Checking if the left side of the ball has touched the left side of the screen
        if self.rect.x &lt;= 0 and not self.rect.colliderect(left_paddle.rect):

            # ? This increments the score for player 1
            right_score += 1

            # ? This resets the entire game
            self.reset(left_paddle, right_paddle)

            # ? waits for a 2 seconds before it resumes gameplay
            wait_timer = 120

        # ? Checking if the right side of the ball has touched the right side of the screen
        if self.rect.x + self.rect.w &gt;= screen_width and not self.rect.colliderect(right_paddle.rect):
            # ? This increments the score for player 2
            left_score += 1
            self.reset(left_paddle, right_paddle)
            # ? waits for a 2 seconds before it resumes gameplay
            wait_timer = 120
</code></pre>
<p>We add the score when the opposite side scores. The value of the <code>wait_timer</code> is set in this section of the collision method for the ball. </p>
<blockquote>
<p>Take note of the fact that we are setting the value of the wait_timer. We would explain later why did so</p>
</blockquote>
<h2 id="the-update-function"><a class="header" href="#the-update-function">The Update function</a></h2>
<p>This function just adds the x and y component of the direction vector the ball’s x and y location every frame.</p>
<p>The function is implemented like</p>
<pre><code class="language-python">    def update(self):
        # ? Adding the x and y components to the x and y position of the ball's rectangle object
        # ? We multiply the vector by a mangitude in order to make the ball move faster
        self.rect.x += self.x_component * self.speed
        self.rect.y += self.y_component * self.speed
</code></pre>
<h2 id="the-show-function"><a class="header" href="#the-show-function">The Show Function</a></h2>
<p>This method draws the ball’s rectangle to the screen</p>
<p>The function is implemented like this</p>
<pre><code class="language-python">    def show(self):
        # ? This just draws the ball's rectangle to the screen
        pygame.draw.rect(display, foreground_color, self.rect)
</code></pre>
<h2 id="finalizing-the-class"><a class="header" href="#finalizing-the-class">Finalizing the Class</a></h2>
<p>We are done with the <code>Ball</code> class. The final code is there below</p>
<pre><code class="language-python"># ? This is the ball object
class Ball:
    def __init__(self):
        # ? This is the size of the ball
        self.size = 20

        # ? This calculates the center position of the screen
        center_horizontal = (screen_width - self.size) / 2
        center_vertical = (screen_height - self.size) / 2

        # ? This is pygame rectangle object that gets drawn onto the screen
        self.rect = pygame.Rect(
            center_horizontal, center_vertical, self.size, self.size)

        # ? This chooses a random angle for velocity vector
        self.angle = random.choice(possible_angles)

        # ? This is the x component of the velocity vector
        self.x_component = cos(radians(self.angle))

        # ? This is the y component of the velocity vector
        self.y_component = sin(radians(self.angle))

        # ? This is the speed of the ball
        self.speed = 15

        # ? This is a variable that fixes a bug
        # ? Check the check_collisions method for more
        self.should_check = True

    def reset(self, left_paddle: Player, right_paddle: Player):
        # ? This changes the angle so that the ball shoots on the side that just recently scored
		self.angle = random.choice(possible_angles)

        # ? This just resets the ball and the paddles position and recalculates the x and y components of the velocity vector
        self.rect.x = (screen_width - self.size) / 2
        self.rect.y = (screen_height - self.size) / 2
        self.x_component = cos(radians(self.angle))
        self.y_component = sin(radians(self.angle))
        left_paddle.reset()
        right_paddle.reset()

    # ? This is kinda like a mini physics enginej
    def check_collisions(self, left_paddle: Player, right_paddle: Player):

        # ? We tell the interpreter that we are about to modify some global variables
        global left_score, right_score, wait_timer

        # ? Checking if the ball collides with the top part or the bottom part of the screen
        if self.rect.y &lt;= 0 or self.rect.y + self.rect.h &gt;= screen_height:
            # ? We just flip the value of the y component
            # ? So for example, if it was moving down it will then start moving up and vice versa
            self.y_component *= -1

        # ? Checking if the ball collides with the left paddle
        if self.rect.colliderect(left_paddle.rect) or self.rect.colliderect(right_paddle.rect):
            # ? So what does this should check variable do
            # ? This is just variable that just specifies if the ball collided with a paddle
            # ? We do this because we want to check the collisions once
            # ? Since when the ball collides with a paddle the x component is reversed
            # ? We only want to reverse the component once
            # ? So why? I bet that's what you are thinking
            # ? When we add the x component to ball's x position we could be inside a paddle
            # ? If we then just flip the vector when it has collided we could flip it multiple times
            # ? Since the should check variable is true by default the flip should only do once and then it should then set it to not check
            # ? Then we are not colliding a paddle anymore we then set the variable to true so when it collides with another paddle it flips the component once
            # ? And then rinse and repeat
            if self.should_check:
                self.x_component *= -1
                self.should_check = False
        else:
            self.should_check = True

        # ? Checking if the left side of the ball has touched the left side of the screen
        if self.rect.x &lt;= 0 and not self.rect.colliderect(left_paddle.rect):

            # ? This increments the score for player 1
            right_score += 1

            # ? This resets the entire game
            self.reset(left_paddle, right_paddle)

            # ? waits for a 2 seconds before it resumes gameplay
            wait_timer = 120

        # ? Checking if the right side of the ball has touched the right side of the screen
        if self.rect.x + self.rect.w &gt;= screen_width and not self.rect.colliderect(right_paddle.rect):
            # ? This increments the score for player 2
            left_score += 1
            self.reset(left_paddle, right_paddle)
            # ? waits for a 2 seconds before it resumes gameplay
            wait_timer = 120

    # ? This method runs every frame
    def update(self):
        # ? Adding the x and y components to the x and y position of the ball's rectangle object
        # ? We multiply the vector by a mangitude in order to make the ball move faster
        self.rect.x += self.x_component * self.speed
        self.rect.y += self.y_component * self.speed

    def show(self):
        # ? This just draws the ball's rectangle to the screen
        pygame.draw.rect(display, foreground_color, self.rect)
</code></pre>
<p>Now that we are done with the ball class we can then move on to the <code>show_score</code> function.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../Pong/Player.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../Pong/Score.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../Pong/Player.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../Pong/Score.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
